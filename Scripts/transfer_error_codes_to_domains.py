#!/usr/bin/env python3

# transfer_error_codes_to_domains.py
# Tansfers all error codes in an Enum / static vars AppErrorCode.swift file into AppErrorDomains.swift

# Ido Rabin @ Feb 2023
# python3


import fileinput
from subprocess import check_output
import re
import sys
import os
from os import path, makedirs
import fileinput
from tempfile import NamedTemporaryFile
from datetime import datetime

SOURCE_FILEPATH = '/Users/syncme/vapor/bserver/Sources/App/App specific/AppError/AppErrorCode.swift'
TARGET_FILEPATH = '/Users/syncme/vapor/bserver/Sources/App/App specific/AppError/AppErrorDomain.swift'

print(f'= transfer_error_codes_to_domains.py is starting: =')

if not os.path.isfile(SOURCE_FILEPATH):
    print(f'❌ bump_build_nr.py failed finding SOURCE_FILEPATH - please correct the path: {SOURCE_FILEPATH}')

if not os.path.isfile(TARGET_FILEPATH):
    print(f'❌ bump_build_nr.py failed finding TARGET_FILEPATH - please correct the path: {TARGET_FILEPATH}')

# This script creates and fills the enum AppErrorDomain : Int with data from the AppErrorCodes file, so that adding an error code is automatically expresed in the

# open Version file
temp_file_name = ''
can_write = False
now = datetime.now() # current date and time
date_time = now.strftime('%d/%m/%Y, %H:%M:%S')
domains = {}
domain_names = {}
domain_maxes = {}
domain_ranges = {}
with open(SOURCE_FILEPATH, mode='r+', encoding='utf-8') as f:
    with NamedTemporaryFile(delete=False, mode='w+', encoding='utf-8') as fout:
        temp_file_name = fout.name
        fout.write('//\n')
        fout.write('// AppErrorDomain.swift\n')
        fout.write('//\n')
        fout.write(f'// Autogenerated for Bricks on Vapor / Leaf as swift. on:{date_time}\n')
        fout.write(f'// Autogenerator using transfer_error_codes_to_domains.py\n')
        fout.write('\n\n')
        fout.write('// Autogenerated by script\n')
        fout.write('enum AppErrorDomain : Int {\n\n')
        code = 0
        maxx = -9999
        name = ''
        domain_code = 0
        domain_name = ''
        comps = ['', '']
        for line in f:
            lne = line.strip()
            if lne.startswith('enum AppErrorCode'):
                can_write = True
                domain_name = "unknown"
                domain_code = 0
                fout.write(f'\tcase {domain_name} =\t{domain_code}\n')
                domain_names[domain_name] = domain_code
                domains[domain_code] = domain_name
            #if can_write and len(lne) == 0:
                #fout.write(f'{line}')
            if 'MAXRANGE' in lne:
                maxx = lne.lstrip('}').strip().lstrip('// MAXRANGE:').strip()
                if int(maxx) >= 0 and int(maxx) < 10000000:
                    maxx = int(maxx)
                    domain_maxes[domain_name] = maxx
                    maxx = -9999
            if can_write and lne.startswith('//'):
                if '== END OF CASES ==' in lne:
                    can_write = False
            elif can_write and lne.startswith('case ') and not (('..<' in lne) or ('...' in lne)) and not lne.startswith('//'):
                comps = line.split('=')
                name = line.strip()
                if len(comps) == 2:
                    parted = comps[1]
                    if '//' in parted:
                        parted = parted.split('//')[0]
                    if int(parted) > 0:
                        code = int(parted)
                        name = comps[0]
                        #print(f'{code} Case line: {lne}');
                else :
                    code += 1
                    #print(f'{code} Case line: {lne}');
                
                # cmd_ prefix has a problem, gets stripped into 'md'..
                if 'case cmd_' in lne:
                    name = 'cmd'
                elif 'case doc_layer_' in lne:
                    name = 'layer'
                elif 'case canceled_' in lne:
                    name = 'cancel'
                else:
                    name = name.lstrip('case ').strip('\'').strip()
                domain_code = int(round((code / 100)) * 100)
                name_parts = name.split('_')
                if len(name_parts) == 1:
                    domain_name = name
                else:
                    domain_name = name_parts[0]
                if not domain_code in domains and not domain_name in domain_names:
                    print(f'{domain_name}:\t{domain_code}..<{maxx}');
                    domain_names[domain_name] = domain_code
                    domains[domain_code] = domain_name
                    fout.write(f'\tcase {domain_name} =\t{domain_code}\n')
        fout.write('\n//\t== END OF CASES ==\n\n')

        # -- Name:
        fout.write('\tvar name : String {\n')
        fout.write('\t\tswitch self {\n')
        for aname in domain_names:
            if aname == 'unknown':
                bname = 'AppError.DEFAULT_DOMAIN'
            else:
                bname = f'"{aname}"'
            fout.write(f'\t\tcase .{aname}:\t\treturn {bname}\n')
        fout.write('\t\t}\n')
        fout.write('\t}\n\n')
        
        # -- Ranges:
        fout.write('\tvar range : Range<Int> {\n')
        fout.write('\t\tswitch self {\n')
        maxx_code = 0
        for aname in domain_names:
            acode = int(domain_names[aname])
            # http status:
            if aname == 'http':
                maxx_code = 100
                acode = 599
            if aname in domain_maxes:
                acode = domain_maxes[aname]
            if aname == 'web':
                maxx_code = 1000
                acode = 1199
            if maxx_code >= acode:
                print(f'❌  {TARGET_FILEPATH} failed updating: range for {aname} is wrong: {maxx_code}...{acode}')
                sys.exit(1)
            fout.write(f'\t\tcase .{aname}:\t\treturn {maxx_code}..<{acode}\n')
            domain_ranges[aname] = f'{maxx_code}..<{acode}'
            maxx_code = acode
            if aname in domain_maxes:
                maxx_code += 1
        fout.write('\t\t}\n')
        fout.write('\t}\n\n')
        
        # -- domain(for code:AppErrorCode)
        fout.write('\tstatic func domain(for code:AppErrorCode)->AppErrorDomain {\n')
        fout.write('\t\treturn self.domain(forIntCode: code.rawValue)\n')
        fout.write('\t}\n\n')
        
        # -- domain(forIntCode:Int)
        fout.write('\tstatic func domain(forIntCode code:Int)->AppErrorDomain {\n')
        fout.write('\t\tswitch code {\n')
        for aname in domain_ranges:
            range = domain_ranges[aname]
            fout.write(f'\t\tcase {range}: return .{aname}\n')
        fout.write('\t\tdefault: return .unknown\n')
        fout.write('\t\t}\n')
        fout.write('\t}\n')
        fout.write('}')

os.rename(temp_file_name, TARGET_FILEPATH)
print(f'✅  {TARGET_FILEPATH} was successfully updated')
